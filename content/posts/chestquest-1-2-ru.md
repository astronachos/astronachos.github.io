---
title: "Сундук Квест: Начало"
date: 2023-05-01
tags: [chestquest]
draft: true
---

## Коллекция

Последние 5 лет я собирал кусочки игровых механик, историй и атмосфер, которые нашли отклик в моем сердце. У каждого разработчика есть такие сундучки с идеями. Все они, безусловно, живут надеждой на реализацию.

Среди этих заметок можно встретить фразу “Неплохо было передать атмосферу роскошного отеля из 80-х”. Или же целую статью, описывающая геймплей, сеттинг, арт-стиль и лор игры с ироничным юмором и разрушением четвертой стены.

Некоторые идеи позаимствованы из DOS игр детства, какие-то являются впечатлением от свежих релизов, а что-то является самобытно выдуманным. Несколько идей были реализованы в виде прототипов ([Love Is In The Air](https://astrochili.itch.io/love-is-in-the-air), [День Кота](https://astronachos.com/catsday), [Shipwrek!](https://astrochili.itch.io/shipwreck)), какие-то заброшены на создании прототипа. Но пока не было ни одного релиза. Если не считать [Rigibi](https://astrochili.github.io/rigibi/) в 2015, которая с большим усилием может потянуть на игру.

## Выбор

И вот, появилась решимость перетряхнуть заметки и наконец что-то сделать. Вовлечено, осмысленно, до релиза. То что нравится мне, то что может нравиться другим, то что вообще реалистично сделать в разумный срок.

Выкинув из списка не вдохновляющие идеи, я отсортировал заметки по значимости ответов на вопросы:

- Сколько потребуется написать кода?
- Сколько потребуется создать контента?
- Насколько конгруэнтен будет недорогой графический стиль?
- Возможно ли реализовать удобное управление для всех платформах?
- Насколько заполнен рынок на потенциальных платформах?
- Насколько успешны аналоги, если такие есть?
- Насколько я сам в восторге от этой идеи?

По всем признакам в лидеры вышла механика небольшой сессионной игры, которую я подсмотрел на itch.io. Если бы пять лет назад кто-то сказал мне, что я захочу сделать мини-игру в жанре match-3, я бы не поверил.

## Ядро

Механика достаточно проста. Игрок начинает с набором предметов в руке. Предметы имеют разные значение и цвет. Игрок размещает их на игровом поле, соблюдая правило соседства предметов по цвету или значению. Образуя цепочки из правильных пар в линию, предметы исчезают с доски, а игрок зарабатывает очки. Если предметы в руке заканчиваются, даются новые. Когда не остается ни одного возможного хода, игра заканчивается.

Вместо уровней здесь прогрессирующая сложность сессии. По мере прогресса, в колоду предметов добавляются новые цвета и значения, препятствия, полезные бонусы. При проигрыше появляется деликатное предложение очистить поле или выдать в руку другие предметы. И, конечно же, небольшой магазин полезностей, которые можно применить во время игры.

## Арт

Обычно, в match-3 играх предметы имеют жесткую связку смысла и цвета, например, желтый кубик солнца, синий кубик воды и т.д. С текущей механикой предметы имеют два независимых признака, что немного усложняет задачу их визуального представления. Нужны достаточно читабельные предметы, чтобы игрок быстро ориентировался на поле, и достаточно красивые, чтобы было что анимировать и к чему присоединять системы частиц.

Как вариант, это могли бы быть RPG предметы, принадлежащие разным стихиям, или загадочные цветные алхимические символы. В игре, где я подсмотрел механику, в качестве предметов используются игровые кости.

Честно говоря, я пока не определился с графическим стилем. Но знаю точно, что стоит реализовать возможность быстрого рескина, на случай если понимание графического стиля придет слишком поздно.

В этой игре нет ни фатальных сражений, ни управления огромным городом. На первый взгляд, кажется что на экране большую часть времени нас ждет весьма статичный пейзаж. Это один из вызовов — сделать отображение статичной модели игры живым, доставить максимально приятный опыт UI / UX. Чтобы удовольствие было от таких простых действий, как перетаскивание предмета из руки на игровое поле.

Как насчет параллакс-эффекта фонового пейзажа по данным акселерометра девайса? Периодичный блеск монеток и булькание зелья? Искры огня от размещении магической сферы? Звуки железа при размещении предмета брони?

## Код

Я вижу достаточно выгодным подходом, когда для пошаговой игры сначала создается игровой модуль, чтобы взаимодействовать с ним через консоль. Это позволяет радикально разделить слои игровой логики и отображения друг от друга. Помимо чистоты и лучшей организации кода, это дает возможность покрыть игровую логику unit-тестами. А еще запускать специального бота, который готов играть в игру без взаимодействия с UI.

VSCode с установленным [Local Lua Debugger](https://marketplace.visualstudio.com/items?itemName=tomblind.local-lua-debugger-vscode) позволяет отлаживать кор-модуль игры с использованием точек останова, независимо от Defold. Мне нравится легковесный опыт написания и тестирования lua модулей используя только редактор кода. Что-то подобное я испытывал, когда создавал прототип [Love Is In The Air](https://astrochili.itch.io/love-is-in-the-air) с использованием фреймворка Love2D в 2016. В дальнейшем это был опыт создания библиотеки [Narrator](https://github.com/astrochili/narrator), где пригодились unit тесты и запуск бота для поиска багов.

Есть еще один плюс. В дальнейшем, можно повторно использовать модуль игры в других игровых движках, использующих lua. Например, если захочется портировать игру на PlayDate.

## Время

Это первый домашний проект, где я фиксирую затраченное время. Ранее, когда я делал [приложения](https://apps.apple.com/us/developer/roman-silin/id975493752), оценки были очень абстрактными. "Ушло около 300 часов, точно не меньше", или "Ну там было три недели, значит по 4 часа в день, и итого получается...". Не очень то прозрачно. А вот теперь то все по настоящему.

![Timetable](/images/timetable.png)

В апреле я посвятил игре 50 часов. Не так много для месяца и не так мало для результата. Легко отвлечься и не заметить, что тратишь время на то, что не улучшает игру.

Мой внутренний перфекционист около 8 часов искал лучший способ реализовать обертку таблицы lua в класс с поддержкой автоматического аннотирования параметров инициализации. Но поможет ли это игре? :)

## Консоль

Какую черту можно подвести прямо сейчас? Я закончил первую версию основного модуля игры. Это выглядит как-то так:

```lua
... Many turns above ...

-= LEVEL 6, POINTS 16 =-
--
[4c] [4a] [  ] [1b] [1a]
[2c] [  ] [  ] [2b] [  ]
[  ] [5b] [C2] [  ] [4d]
[**] [  ] [3a] [3c] [  ]
[6a] [7a] [  ] [3d] [6d]

[__]-[RR]-[__]-[**]-[6b]
--

<- Place [**] to 3:1
-> BOARD_UPDATE.PLACEMENT positions: 3:1
-> BOARD_UPDATE.MATCH positions: 1:1 2:1 4:1 5:1 3:1
-> GAME_POINTS.MATCH amount: 10
-> HAND_UPDATE.PLACEMENT indexes: 4

... Many turns below ...
```

Вот так глупенький бот может играть в игру в консоли, а я наблюдать за результатом его ходов.

## Модуль игры

Что насчет кода?

```lua
local levels = {
  [1] = '>>>>^^^^####cccvvvvvv',
  [3] = 'cu',
  [5] = 'cuddrr',
  [7] = 'cbbss',
  [10] = '>^#cv',
}

local player = Player {
  coins = 100
}

local game = Game {
  levels = levels,
  player = player,
}
```

`levels` — что-то вроде кривой сложности. На каких уровнях и что именно добавлять в общий пул предметов. Когда игрок размещает все предметы из руки и получает новые, происходит поднятие уровня. Сейчас это простая таблица, размещенная локально, но в дальнейшем лучше будет загружать ее с сервера.

- `c` - добавление нового цвета;
- `c` - добавление нового значения;
- `>` - расширение игрового поля в ширину;
- `^` - расширение игрового поля в высоту;
- `#` - расширение места в руке;
- `u` - универсальный предмет, совпадающий со любыми значениями и цветами;
- и т.д.

`player` — на данный момент это хранилище валюты и приобретенных предметов.

`game` — экземпляр игровой сессии. Прочесть текущее состояние игровых компонентов  мы можем через `game.player`, `game.points`,`game.board` и `game.hand`. Для красивого вывода состояния игры в консоль я реализовал в каждом компоненте метод мета-таблицы `__tostring`, который позволяет получить текстовое представление вызовом `tostring(game)`.

```lua
local item = game.hand.slots[slot_index]
local valid_positions = game:get_valid_positions(item)
local events = game:make_turn(slot_index, valid_positions[1])
```

Для совершения хода мы выбираем предмет в руке игрока и проверяем, какие есть доступные, соответствующие правилам игры, позиции на доске, на которые можно разместить этот предмет. Определив интересную позицию, совершаем ход, сообщив модулю игры номер слота руки с предметом и целевую позицию куда намерены его разместить.

```lua
-> BOARD_UPDATE.PLACEMENT positions: 3:1
-> BOARD_UPDATE.MATCH positions: 1:1 2:1 4:1 5:1 3:1
-> GAME_POINTS.MATCH amount: 10
-> HAND_UPDATE.PLACEMENT indexes: 1 2 3 4
```

В ответ игра возвращает список событий, которые с ней произошли. Если ориентироваться только на чтение нового состояния игры, можно легко упустить какие-либо промежуточные события, требующее последовательности в анимациях. Такие ответы с событиями помогают соблюсти эту последовательность. Например:

1. Предмет красиво размещается на доске испуская легкие искры.
2. Происходит взрыв линии предметов с молниями и вспышками.
3. Счетчик очков игрока начинает обороты, цифры крутятся, останавливаются.
4. Пустая рука заполняется новыми предметами.

## Больше примеров

Еще немного примеров. Здесь игрок покупает предмет в магазине и использует его во время игры.

```lua
local shop = Shop {
  reroll = { price = 10 },
  bomb = { price = 20 },
  double = { price = 10 },
  universal = { price = 5 }
}

if shop:can_afford(player, 'reroll', 1) then
    shop:buy(player, 'reroll', 1)
end

if player.items['reroll'] > 0 then
    local item = player:pop_item('reroll')
    local valid_positions = game:get_valid_positions(item)
    local events = game:use_item(item, valid_positions[1])
end
```

А вот пример особенного предмета `бомба`, который позволяет расчистить игровое поле.

```lua
local bomb = { }

function bomb:init()
  -- Nothing special for a bomb
end

function bomb:debug_description()
  return '[BM]'
end

function bomb:can_be_placed_with(other_item)
  return true
end

function bomb:is_self_destructive()
  return true
end

function bomb:affect_on_game(game)
  local items = game.board:clear_all()
  game.master:return_to_pool(items)

  game:add_event_to_stack {
    event = events.BOARD_UPDATE,
    reason = event_reasons.BOMB,
  }
end

return kit.wrap_to_class(bomb)
```

## Что дальше?

Сейчас все готово чтобы создать проект в Defold и приступить к реализации взаимодействия между модулем игры и UI. Для сборки первого прототипа я постараюсь начать с максимально нейтральной и примитивной графики, а потом, постепенно, буду пробовать ее подменять на какой-либо конкретный графический стиль.
